/**
 * Created by kayslay on 4/23/17.
 */
let _ = require('lodash');
let path = require('path');
let urlModule = require('url');


/**
 * @description returns true if the keys of two objects match and false if otherwise
 * @param obj1 first object
 * @param obj2 second object
 * @return {boolean}
 */
function keyMatch(obj1, obj2) {
    let key1 = Object.keys(obj1).sort();
    let key2 = Object.keys(obj2).filter(k => (key1.indexOf(k) != -1)).sort();
    return _.isEqual(key1, key2);
}

/**
 * @description converts a relative url to an absolute url
 * @param url the current url
 * @param urlPath the url path to resolve
 * @return {string}
 */
function toAbsoluteUrl(url, urlPath) {
    let getUrl = getUrlOut(url);
    let parsedUrl = urlModule.parse(getUrl);
    return `${parsedUrl.protocol}//${parsedUrl.host}${path.join(parsedUrl.pathname, urlPath)}${parsedUrl.search || ''}`
        .replace(/(\w|\d)\/\//g, "$1\/")
        .replace(/\/?#.+$/, '');
}

/**
 * @description returns the url string
 * if the url param is an object get the return the url property
 * @param url {String|Object}
 * @return {string} the string generated by the function
 */
function getUrlOut(url) {
    if (typeof url === 'string') {
        return url;
    } else if (typeof url == 'object') {
        return url.url;
    }
}

/**
 * @description generate a unique string identifier to marks a link has visited
 * @param {String|Object} url 
 */
function genUniqueVisitedString(url) {
    // TODO make the identifier better. should support headers and all http request features
    if (typeof url === 'string') {
        const {
            host,
            path,
            protocol
        } = urlModule.parse(url)
        return `[GET] ${protocol}//${host}${path}`;
    } else if (typeof url == 'object') {
        const {
            host,
            path,
            protocol
        } = urlModule.parse(url.url)
        return `[${url.method?`${url.method.toUpperCase()}`:'GET'}] ${protocol}//${host}${path}`;
    }
}

/**
 * @description coverts the return data to an array
 * @param data
 * @return {String[]}
 */
function sortDataToArray(data) {
    return data.reduce((acc, item) => {

        let packedItem = [];
        for (let i in item) {
            packedItem = packedItem.concat(item[i]);
        }
        return acc.concat(packedItem)
    }, [])
}

/**
 * @description the default formatUrl callback. The formatUrl is used to format the url to crawl next
 * if there is a need to change the url for any reason it can be used.
 * 
 * Example: This function changes any url that match "http://wiki.com/" and returns a new url that makes a HEAD method request to the url.
 * any url not matching "http://wiki.com/" is returned as it is.
 *  
 * function(url){
 *   if (/http:\/\/wiki.com\/?/.test(url)){
 *      return {url:"https://wiki.org", method:"HEAD"}
 *      }
 *  return url
 * }
 * @param {String} url the url string
 * @return {String|Object}
 */
function formatUrl(url) {
    return url;
}

/**
 * @description returns the selector that would be used to crawl the page.
 * @param url
 * @param {Object} dynamic the object that will replace the default selector
 * @param {Object} defaultSelection the default selection
 * @return {*}
 */
function dynamicSelection(url, dynamic, defaultSelection) {
    if (dynamic) {
        let formattedUrl = getUrlOut(url);
        for (let x of dynamic) {
            if (x.url.test(formattedUrl)) {
                return x.schema;
            }
        }
    }
    return defaultSelection
}

function empty(obj) {
    for (let i in obj) {
        return false
    }
    return true
}

/**
 * @description changes the relative urls to absolute urls
 * @param contentData
 * @param url
 */
function relativeToAbsoluteUrl(contentData, url) {
    for (let name in contentData) {
        contentData[name] = contentData[name].map(returnAbsoluteUrl)
    }

    function returnAbsoluteUrl(item) {
        if (/^(https?)/.test(item)) {
            return item
        }
        return util.toAbsoluteUrl(url, item)
    }
}

/**
 * @description resolves a promise after time ms
 * @param {number} time the time to wait
 * @param {function} cb a callback to execute when the wait is over
 */
function delay(time, cb) {
    return new Promise((resolve, reject) => setTimeout(args => {
        resolve(null);
        (typeof cb == 'function') && cb()
    }, time))
}


let util = {
    keyMatch,
    sortDataToArray,
    toAbsoluteUrl,
    formatUrl,
    dynamicSelection,
    relativeToAbsoluteUrl,
    genUniqueVisitedString,
    empty,
    delay,
};
exports = module.exports = util;